#!/bin/bash

# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2009-2016 Stephan Raue (stephan@openelec.tv)
# Copyright (C) 2018-present Team LibreELEC (https://libreelec.tv)

. config/options "${1}"

#echo "build 传入参数:" ${1}

#检查参数是否合法
#echo "检查参数是否合法"
if [ -z "${1}" ]; then
  die "usage: ${0} package_name[:<host|target|init|bootstrap>] [parent_pkg]"
fi

#批量构建的功能实现。它允许用户为所有已配置的构建目标，一次性触发某个特定包的构建。
#echo "批量构建的功能实现"
if [ "${1}" = "--all" ]; then
  if [ -n "${2}" ]; then
    for build_dir in $(ls -1d ${ROOT}/build.*); do
      load_build_config ${build_dir} && ${SCRIPTS}/build "${2}"
    done
  fi
  exit 0
fi

#用于验证当前处理的包是否存在对应的 .mk 配置文件
#echo "验证当前处理的包是否存在对应的 .mk 配置文件"
if [ -z "${PKG_NAME}" ]; then
  die "$(print_color CLR_ERROR "${1}: no package.mk file found")"
fi

#包的架构兼容性检查
#echo "兼容性检查"
if [ -n "${PKG_ARCH}" ]; then
  listcontains "${PKG_ARCH}" "!${TARGET_ARCH}" && exit 0
  listcontains "${PKG_ARCH}" "${TARGET_ARCH}" || listcontains "${PKG_ARCH}" "any" || exit 0
fi

#参数处理与默认值设置逻辑
#echo "参数处理"
if [ "${1//:/}" != "${1}" ]; then
  TARGET="${1#*:}"
else
  TARGET=
fi
TARGET="${TARGET:-target}"
PARENT_PKG="${2:-${PKG_NAME}:${TARGET}}"

#为某个包的构建操作创建一个锁
#echo "构建操作创建锁"
pkg_lock "${PKG_NAME}:${TARGET}" "build" "${PARENT_PKG}"


#echo "创建文件夹" ${STAMPS} / ${PKG_NAME}
mkdir -p ${STAMPS}/${PKG_NAME}

#实现 ** 增量构建（Incremental Build）和可重现构建（Reproducible Build）** 的核心逻辑。
#它通过一个 “构建标记文件”（Stamp File）来判断一个包是否需要重新构建
#定义一个 “构建标记文件” 的路径。
#如果该标记文件存在，则加载它。
#计算当前包的 “深度哈希值”（一个代表所有构建输入状态的哈希）。
#将当前计算的哈希值与标记文件中记录的旧哈希值进行比较。
#如果哈希值和调试模式都匹配，说明构建输入没有变化，无需重新构建，脚本解锁并退出。
#如果不匹配，说明构建输入已改变，需要重新构建，因此删除旧的标记文件

#第 1 行：STAMP=${STAMPS}/${PKG_NAME}/build_${TARGET}
#STAMP=：定义一个变量 STAMP，用于存储标记文件的完整路径。
#${STAMPS}：一个预先定义的环境变量，指向构建系统中用于存放所有标记文件的根目录。
#/${PKG_NAME}：为每个包创建一个单独的子目录，避免不同包的标记文件冲突。
#/build_${TARGET}：标记文件本身的名称。
#build_ 前缀明确指出这是 “构建” 阶段的标记。
#${TARGET} 后缀（例如 host 或 target）用于区分同一个包在不同目标平台上的构建状态。
#举例：如果 STAMPS=/path/to/stamps，PKG_NAME=zlib，TARGET=host，那么 STAMP 变量的值就是：/path/to/stamps/zlib/build_host
STAMP=${STAMPS}/${PKG_NAME}/build_${TARGET}
#echo "构建文件的完整路径/" $STAMP

#检查 STAMP 变量所指向的文件是否存在且为一个普通文件
if [ -f ${STAMP} ]; then
  #echo "构建文件的路径已存在"
  #加载标记文件的内容。这个标记文件通常不是一个脚本，而是一系列变量的定义。例如，它的内容可能看起来像这样
  . ${STAMP}
  #计算 “深度哈希值”。
  PKG_DEEPHASH=$(calculate_stamp)

  #比较当前计算的哈希值和上次构建时记录的哈希值 比较当前的调试模式和上次构建时的调试模式
  if [ "${PKG_DEEPHASH}" = "${STAMP_PKG_DEEPHASH}" -a "${BUILD_WITH_DEBUG}" = "${STAMP_BUILD_WITH_DEBUG}" ]; then
    # stamp matched: already built, do nothing
    pkg_lock_status "UNLOCK" "${PKG_NAME}:${TARGET}" "build" "already built"
    echo "检测到存在的构建文件无需重新构建"
    exit 0
  fi

  #如果不匹配重新构建
  echo "检测到存在的构建文件需要重新构建"
  rm -f ${STAMP}
fi
echo "构建文件的路径不存在 需要重新构建"

#解压和准备好当前包（${PKG_NAME}）的源代码，为后续的配置和编译步骤做准备
echo "SCRIPTS:" ${SCRIPTS}
echo "PKG_NAME:" ${PKG_NAME}
echo "PKG_NPARENT_PKGAME:" ${PARENT_PKG}
${SCRIPTS}/unpack "${PKG_NAME}" "${PARENT_PKG}"

# build dependencies, only when PKG_DEPENDS_? is filled
# 根据当前的构建目标（TARGET），找到对应的依赖包列表，然后逐一构建这些依赖包
unset _pkg_depends
case "${TARGET}" in
  "target") _pkg_depends="${PKG_DEPENDS_TARGET}";;
  "host") _pkg_depends="${PKG_DEPENDS_HOST}";;
  "init") _pkg_depends="${PKG_DEPENDS_INIT}";;
  "bootstrap") _pkg_depends="${PKG_DEPENDS_BOOTSTRAP}";;
esac
for p in ${_pkg_depends}; do
  ${SCRIPTS}/build "${p}" "${PARENT_PKG}"
done

# virtual packages are not built as they only contain dependencies, so dont go further here
#构建系统中处理 **“虚拟包”（Virtual Packages）** 的逻辑。
#虚拟包本身不包含任何需要编译的源代码，它的唯一作用是定义一组依赖关系
if [ "${PKG_SECTION}" = "virtual" ]; then
  PKG_DEEPHASH=$(calculate_stamp)
  for i in PKG_NAME PKG_DEEPHASH BUILD_WITH_DEBUG; do
    echo "STAMP_${i}=\"${!i}\"" >> ${STAMP}
  done

  pkg_lock_status "UNLOCK" "${PKG_NAME}:${TARGET}" "build" "built"
  echo "PKG_SECTION 为 virtual 退出 build"
  exit 0
fi

# build this package
# 编译包
if [ "${BUILD_WITH_DEBUG}" = "yes" ]; then
  echo "DEBUG编译模式"
  build_msg "CLR_BUILD" "BUILD" "${PKG_NAME} $(print_color "CLR_TARGET" "(${TARGET})") [DEBUG]" "indent"
else
  echo "常规编译模式"
  build_msg "CLR_BUILD" "BUILD" "${PKG_NAME} $(print_color "CLR_TARGET" "(${TARGET})")" "indent"
fi

echo "设定编译工具"
setup_toolchain ${TARGET}

# configure install directory
# 根据当前的构建目标（TARGET），来设置或清空 INSTALL 环境变量，从而决定后续安装操作的目的地
if [ "${TARGET}" = "target" ]; then
  INSTALL="${PKG_BUILD}/.install_pkg"
elif [ "${TARGET}" = "init" ]; then
  INSTALL="${PKG_BUILD}/.install_init"
else
  unset INSTALL
fi
echo "INSTALL最终目录:" ${INSTALL}

# remove previous install files
# 移除已经产生的安装文件
echo "移除已经产生的安装文件"
if [ -n "${INSTALL}" -a -d "${INSTALL}" ]; then
  rm -rf "${INSTALL}"
fi

# configure debug build defaults
# 配置调试模式下的默认设定
echo "配置调试模式下的默认设定"
if [ "${BUILD_WITH_DEBUG}" = "yes" ]; then
  CMAKE_BUILD_TYPE="Debug"
  MESON_BUILD_TYPE="debug"
else
  CMAKE_BUILD_TYPE="Release"
  MESON_BUILD_TYPE="plain"
fi

CMAKE_GENERATOR_NINJA="-GNinja \
                       -DCMAKE_EXPORT_COMPILE_COMMANDS=ON"

# configure TARGET build defaults
TARGET_CONFIGURE_OPTS="--host=${TARGET_NAME} \
                       --build=${HOST_NAME} \
                       --prefix=/usr \
                       --bindir=/usr/bin \
                       --sbindir=/usr/sbin \
                       --sysconfdir=/etc \
                       --libdir=/usr/lib \
                       --libexecdir=/usr/lib \
                       --localstatedir=/var \
                       --disable-static \
                       --enable-shared"

TARGET_CMAKE_OPTS="-DCMAKE_TOOLCHAIN_FILE=${CMAKE_CONF} \
                   -DCMAKE_INSTALL_PREFIX=/usr \
                   -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} \
                   -Wno-dev"

TARGET_MESON_OPTS="--prefix=/usr \
                   --bindir=/usr/bin \
                   --sbindir=/usr/sbin \
                   --sysconfdir=/etc \
                   --libdir=/usr/lib \
                   --libexecdir=/usr/lib \
                   --localstatedir=/var \
                   --buildtype=${MESON_BUILD_TYPE}"

# configure HOST build defaults
HOST_CONFIGURE_OPTS="--host=${HOST_NAME} \
                     --build=${HOST_NAME} \
                     --prefix=${TOOLCHAIN} \
                     --bindir=${TOOLCHAIN}/bin \
                     --sbindir=${TOOLCHAIN}/sbin \
                     --sysconfdir=${TOOLCHAIN}/etc \
                     --libexecdir=${TOOLCHAIN}/lib \
                     --localstatedir=${TOOLCHAIN}/var \
                     --disable-static \
                     --enable-shared"

HOST_CMAKE_OPTS="${CMAKE_GENERATOR} \
                 -DCMAKE_TOOLCHAIN_FILE=${CMAKE_CONF} \
                 -DCMAKE_INSTALL_PREFIX=${TOOLCHAIN} \
                 -Wno-dev"

HOST_MESON_OPTS="--prefix=${TOOLCHAIN} \
                 --bindir=${TOOLCHAIN}/bin \
                 --sbindir=${TOOLCHAIN}/sbin \
                 --sysconfdir=${TOOLCHAIN}/etc \
                 --libdir=${TOOLCHAIN}/lib \
                 --libexecdir=${TOOLCHAIN}/lib \
                 --localstatedir=${TOOLCHAIN}/var \
                 --buildtype=plain"

# configure INIT build defaults
INIT_CONFIGURE_OPTS="${TARGET_CONFIGURE_OPTS}"
INIT_CMAKE_OPTS="${TARGET_CMAKE_OPTS}"
INIT_MESON_OPTS="${TARGET_MESON_OPTS}"

# configure BOOTSTRAP build defaults
BOOTSTRAP_CONFIGURE_OPTS="${HOST_CONFIGURE_OPTS}"
BOOTSTRAP_CMAKE_OPTS="${HOST_CMAKE_OPTS}"
BOOTSTRAP_MESON_OPTS="${HOST_MESON_OPTS}"

# setup configure scripts
PKG_CONFIGURE_SCRIPT="${PKG_CONFIGURE_SCRIPT:-${PKG_BUILD}/configure}"
PKG_CMAKE_SCRIPT="${PKG_CMAKE_SCRIPT:-${PKG_BUILD}/CMakeLists.txt}"
PKG_MESON_SCRIPT="${PKG_MESON_SCRIPT:-${PKG_BUILD}/meson.build}"

# auto detect toolchain
echo "自动配置工具链"
_auto_toolchain=""
if [ -z "${PKG_TOOLCHAIN}" -o "${PKG_TOOLCHAIN}" = "auto" ]; then
  if [ -f "${PKG_MESON_SCRIPT}" ]; then
    PKG_TOOLCHAIN="meson"
  elif [ -f "${PKG_CMAKE_SCRIPT}" ]; then
    PKG_TOOLCHAIN="cmake"
  elif [ -f "${PKG_CONFIGURE_SCRIPT}" ]; then
    PKG_TOOLCHAIN="configure"
  elif [ -f "${PKG_BUILD}/Makefile" ]; then
    PKG_TOOLCHAIN="make"
  else
    die "Not possible to detect toolchain automatically. Add PKG_TOOLCHAIN= to package.mk"
  fi
  _auto_toolchain=" (auto-detect)"
fi

if ! listcontains "meson cmake cmake-make configure ninja make autotools manual" "${PKG_TOOLCHAIN}"; then
  die "$(print_color "CLR_ERROR" "ERROR:") unknown toolchain ${PKG_TOOLCHAIN}"
fi
build_msg "CLR_TOOLCHAIN" "TOOLCHAIN" "${PKG_TOOLCHAIN}${_auto_toolchain}"

# make autoreconf
echo "make 脚本自动配置"
echo "SCRIPTS/autoreconf PKG_NAME PARENT_PKG" ${SCRIPTS} ${PKG_NAME} ${PARENT_PKG}
if [ "${PKG_TOOLCHAIN}" = "autotools" ]; then
  ${SCRIPTS}/autoreconf "${PKG_NAME}" "${PARENT_PKG}"
fi

#锁定编译需要的配置文件
pkg_lock_status "ACTIVE" "${PKG_NAME}:${TARGET}" "build"

# include build template and build
echo "PKG回调安装配置和运行"
pkg_call_exists pre_build_${TARGET} && pkg_call pre_build_${TARGET}

# ensure ${PKG_BUILD} is there. (installer? PKG_URL="")
echo "创建PKG_BUILD存放目录" ${PKG_BUILD}
mkdir -p "${PKG_BUILD}"

cd "${PKG_BUILD}"

if [ -f "${PKG_CONFIGURE_SCRIPT}" -o -f "${PKG_CMAKE_SCRIPT}" -o -f "${PKG_MESON_SCRIPT}" ]; then
  case "${TARGET}" in
    "target")    PKG_REAL_BUILD="${PKG_BUILD}/.${TARGET_NAME}" ;;
    "host")      PKG_REAL_BUILD="${PKG_BUILD}/.${HOST_NAME}" ;;
    "init")      PKG_REAL_BUILD="${PKG_BUILD}/.${TARGET_NAME}-${TARGET}" ;;
    "bootstrap") PKG_REAL_BUILD="${PKG_BUILD}/.${HOST_NAME}-${TARGET}" ;;
  esac
  mkdir -p "${PKG_REAL_BUILD}"
  cd "${PKG_REAL_BUILD}"

  MESON_CONF="${PKG_REAL_BUILD}/meson.conf"
fi

# create wrapper scripts in build dir and use them for CC/CXX when
# building for host and local-cc build flag is set
echo "编译主机local-cc"
if [ "${TARGET}" = "host" ] && flag_enabled "local-cc" "no"; then
  cat > libreelec-local-cc << EOF
#!/bin/sh
exec ${CC} "\$@"
EOF
  chmod +x libreelec-local-cc
  export CC=$(pwd)/libreelec-local-cc
  cat > libreelec-local-cxx << EOF
#!/bin/sh
exec ${CXX} "\$@"
EOF
  chmod +x libreelec-local-cxx
  export CXX=$(pwd)/libreelec-local-cxx
fi

# configure
echo "配置PKG configure"
pkg_call_exists pre_configure && pkg_call pre_configure
pkg_call_exists pre_configure_${TARGET} && pkg_call pre_configure_${TARGET}


if pkg_call_exists configure_${TARGET}; then
  pkg_call configure_${TARGET}
else
  case "${PKG_TOOLCHAIN}:${TARGET}" in
    # meson builds
    "meson:target")
      create_meson_conf ${TARGET} ${MESON_CONF}
      echo "Executing (target): meson ${TARGET_MESON_OPTS} --cross-file=${MESON_CONF} ${PKG_MESON_OPTS_TARGET} $(dirname ${PKG_MESON_SCRIPT})" | tr -s " "
      CC="${HOST_CC}" CXX="${HOST_CXX}" meson ${TARGET_MESON_OPTS} --cross-file=${MESON_CONF} ${PKG_MESON_OPTS_TARGET} $(dirname ${PKG_MESON_SCRIPT})
      ;;
    "meson:host")
      create_meson_conf ${TARGET} ${MESON_CONF}
      echo "Executing (host): meson ${HOST_MESON_OPTS} --cross-file=${MESON_CONF} ${PKG_MESON_OPTS_HOST} $(dirname ${PKG_MESON_SCRIPT})" | tr -s " "
      meson ${HOST_MESON_OPTS} --cross-file=${MESON_CONF} ${PKG_MESON_OPTS_HOST} $(dirname ${PKG_MESON_SCRIPT})
      ;;
    "meson:init")
      create_meson_conf ${TARGET} ${MESON_CONF}
      echo "Executing (init): meson ${INIT_MESON_OPTS} --cross-file=${MESON_CONF} ${PKG_MESON_OPTS_INIT} $(dirname ${PKG_MESON_SCRIPT})" | tr -s " "
      meson ${INIT_MESON_OPTS} --cross-file=${MESON_CONF} ${PKG_MESON_OPTS_INIT} $(dirname ${PKG_MESON_SCRIPT})
      ;;
    "meson:bootstrap")
      create_meson_conf ${TARGET} ${MESON_CONF}
      echo "Executing (bootstrap): meson ${BOOTSTRAP_MESON_OPTS} --cross-file=${MESON_CONF} ${PKG_MESON_OPTS_BOOTSTRAP} $(dirname ${PKG_MESON_SCRIPT})" | tr -s " "
      meson ${BOOTSTRAP_MESON_OPTS} --cross-file=${MESON_CONF} ${PKG_MESON_OPTS_BOOTSTRAP} $(dirname ${PKG_MESON_SCRIPT})
      ;;

    # cmake builds with ninja
    "cmake:target")
      echo "Executing (target): cmake ${CMAKE_GENERATOR_NINJA} ${TARGET_CMAKE_OPTS} ${PKG_CMAKE_OPTS_TARGET} $(dirname ${PKG_CMAKE_SCRIPT})" | tr -s " "
      cmake ${CMAKE_GENERATOR_NINJA} ${TARGET_CMAKE_OPTS} ${PKG_CMAKE_OPTS_TARGET} $(dirname ${PKG_CMAKE_SCRIPT})
      ;;
    "cmake:host")
      echo "Executing (host): cmake ${CMAKE_GENERATOR_NINJA} ${HOST_CMAKE_OPTS} ${PKG_CMAKE_OPTS_HOST} $(dirname ${PKG_CMAKE_SCRIPT})" | tr -s " "
      cmake ${CMAKE_GENERATOR_NINJA} ${HOST_CMAKE_OPTS} ${PKG_CMAKE_OPTS_HOST} $(dirname ${PKG_CMAKE_SCRIPT})
      ;;
    "cmake:init")
      echo "Executing (init): cmake ${CMAKE_GENERATOR_NINJA} ${INIT_CMAKE_OPTS} ${PKG_CMAKE_OPTS_INIT} $(dirname ${PKG_CMAKE_SCRIPT})" | tr -s " "
      cmake ${CMAKE_GENERATOR_NINJA} ${INIT_CMAKE_OPTS} ${PKG_CMAKE_OPTS_INIT} $(dirname ${PKG_CMAKE_SCRIPT})
      ;;
    "cmake:bootstrap")
      echo "Executing (bootstrap): cmake ${CMAKE_GENERATOR_NINJA} ${BOOTSTRAP_CMAKE_OPTS} ${PKG_CMAKE_OPTS_BOOTSTRAP} $(dirname ${PKG_CMAKE_SCRIPT})" | tr -s " "
      cmake ${CMAKE_GENERATOR_NINJA} ${BOOTSTRAP_CMAKE_OPTS} ${PKG_CMAKE_OPTS_BOOTSTRAP} $(dirname ${PKG_CMAKE_SCRIPT})
      ;;

    # cmake builds with make
    "cmake-make:target")
      echo "Executing (target): cmake ${TARGET_CMAKE_OPTS} ${PKG_CMAKE_OPTS_TARGET} $(dirname ${PKG_CMAKE_SCRIPT})" | tr -s " "
      cmake ${TARGET_CMAKE_OPTS} ${PKG_CMAKE_OPTS_TARGET} $(dirname ${PKG_CMAKE_SCRIPT})
      ;;
    "cmake-make:host")
      echo "Executing (host): cmake ${HOST_CMAKE_OPTS} ${PKG_CMAKE_OPTS_HOST} $(dirname ${PKG_CMAKE_SCRIPT})" | tr -s " "
      cmake ${HOST_CMAKE_OPTS} ${PKG_CMAKE_OPTS_HOST} $(dirname ${PKG_CMAKE_SCRIPT})
      ;;
    "cmake-make:init")
      echo "Executing (init): cmake ${INIT_CMAKE_OPTS} ${PKG_CMAKE_OPTS_INIT} $(dirname ${PKG_CMAKE_SCRIPT})" | tr -s " "
      cmake ${INIT_CMAKE_OPTS} ${PKG_CMAKE_OPTS_INIT} $(dirname ${PKG_CMAKE_SCRIPT})
      ;;
    "cmake-make:bootstrap")
      echo "Executing (bootstrap): cmake ${BOOTSTRAP_CMAKE_OPTS} ${PKG_CMAKE_OPTS_BOOTSTRAP} $(dirname ${PKG_CMAKE_SCRIPT})" | tr -s " "
      cmake ${BOOTSTRAP_CMAKE_OPTS} ${PKG_CMAKE_OPTS_BOOTSTRAP} $(dirname ${PKG_CMAKE_SCRIPT})
      ;;

    # configure builds
    "configure:target"|"autotools:target")
      echo "Executing (target): ${PKG_CONFIGURE_SCRIPT} ${TARGET_CONFIGURE_OPTS} ${PKG_CONFIGURE_OPTS_TARGET}" | tr -s " "
      ${PKG_CONFIGURE_SCRIPT} ${TARGET_CONFIGURE_OPTS} ${PKG_CONFIGURE_OPTS_TARGET}
      ;;
    "configure:host"|"autotools:host")
      echo "Executing (host): ${PKG_CONFIGURE_SCRIPT} ${HOST_CONFIGURE_OPTS} ${PKG_CONFIGURE_OPTS_HOST}" | tr -s " "
      ${PKG_CONFIGURE_SCRIPT} ${HOST_CONFIGURE_OPTS} ${PKG_CONFIGURE_OPTS_HOST}
      ;;
    "configure:init"|"autotools:init")
      echo "Executing (init): ${PKG_CONFIGURE_SCRIPT} ${INIT_CONFIGURE_OPTS} ${PKG_CONFIGURE_OPTS_INIT}" | tr -s " "
      ${PKG_CONFIGURE_SCRIPT} ${INIT_CONFIGURE_OPTS} ${PKG_CONFIGURE_OPTS_INIT}
      ;;
    "configure:bootstrap"|"autotools:bootstrap")
      echo "Executing (bootstrap): ${PKG_CONFIGURE_SCRIPT} ${BOOTSTRAP_CONFIGURE_OPTS} ${PKG_CONFIGURE_OPTS_BOOTSTRAP}" | tr -s " "
      ${PKG_CONFIGURE_SCRIPT} ${BOOTSTRAP_CONFIGURE_OPTS} ${PKG_CONFIGURE_OPTS_BOOTSTRAP}
      ;;
  esac
fi

pkg_call_exists post_configure_${TARGET} && pkg_call post_configure_${TARGET}

# make
echo "开始执行make"
pkg_call_exists pre_make_${TARGET} && pkg_call pre_make_${TARGET}
echo "make执行完毕"

if pkg_call_exists make_${TARGET}; then
  pkg_call make_${TARGET}
else
  case "${PKG_TOOLCHAIN}:${TARGET}" in
    # ninja based builds
    "meson:target"|"cmake:target"|"ninja:target")
      echo "Executing (target): ninja ${PKG_MAKE_OPTS_TARGET}" | tr -s " "
      ninja ${NINJA_OPTS} ${PKG_MAKE_OPTS_TARGET}
      ;;
    "meson:host"|"cmake:host"|"ninja:host")
      echo "Executing (host): ninja ${PKG_MAKE_OPTS_HOST}" | tr -s " "
      ninja ${NINJA_OPTS} ${PKG_MAKE_OPTS_HOST}
      ;;
    "meson:init"|"cmake:init"|"ninja:init")
      echo "Executing (init): ninja ${PKG_MAKE_OPTS_INIT}" | tr -s " "
      ninja ${NINJA_OPTS} ${PKG_MAKE_OPTS_INIT}
      ;;
    "meson:bootstrap"|"cmake:bootstrap"|"ninja:bootstrap")
      echo "Executing (bootstrap): ninja ${PKG_MAKE_OPTS_BOOTSTRAP}" | tr -s " "
      ninja ${NINJA_OPTS} ${PKG_MAKE_OPTS_BOOTSTRAP}
      ;;

    # make based builds
    "configure:target"|"cmake-make:target"|"autotools:target"|"make:target")
      echo "Executing (target): make ${PKG_MAKE_OPTS_TARGET}" | tr -s " "
      make ${PKG_MAKE_OPTS_TARGET}
      ;;
    "configure:host"|"cmake-make:host"|"autotools:host"|"make:host")
      echo "Executing (host): make ${PKG_MAKE_OPTS_HOST}" | tr -s " "
      make ${PKG_MAKE_OPTS_HOST}
      ;;
    "configure:init"|"cmake-make:init"|"autotools:init"|"make:init")
      echo "Executing (init): make ${PKG_MAKE_OPTS_INIT}" | tr -s " "
      make ${PKG_MAKE_OPTS_INIT}
      ;;
    "configure:bootstrap"|"cmake-make:bootstrap"|"autotools:bootstrap"|"make:bootstrap")
      echo "Executing (bootstrap): make ${PKG_MAKE_OPTS_BOOTSTRAP}" | tr -s " "
      make ${PKG_MAKE_OPTS_BOOTSTRAP}
      ;;
  esac
fi

echo "执行 post_make 环节"
pkg_call_exists post_make_${TARGET} && pkg_call post_make_${TARGET}

# Hack around directly writing/modifying the content of a shared sysroot
# by temporarily installing new files to a package specific sysroot
echo "导出系统环境变量"
PKG_ORIG_SYSROOT_PREFIX="${SYSROOT_PREFIX}"
export SYSROOT_PREFIX="${BUILD}/.sysroot/${PKG_NAME}.${TARGET}"
rm -rf "${SYSROOT_PREFIX}"

# Create common sysroot directories as some packages expect them to exist.
# TODO: Fix those packages so we don't need to pre-create directories.
echo "注册 SYSROOT pkgconfig"
for d in /usr/lib /usr/include /usr/bin /usr/lib/pkgconfig; do
  mkdir -p "${SYSROOT_PREFIX}${d}"
done

# make install
echo "pre_makeinstall 环节"
pkg_call_exists pre_makeinstall_${TARGET} && pkg_call pre_makeinstall_${TARGET}

echo "makeinstall 环节"
if pkg_call_exists makeinstall_${TARGET}; then
  echo "检测到有默认makeinstall函数直接调用"
  pkg_call makeinstall_${TARGET}
  echo "调用makeinstall函数完毕"
else
  case "${PKG_TOOLCHAIN}:${TARGET}" in
    # ninja based builds
    "meson:target"|"cmake:target")
      DESTDIR=${SYSROOT_PREFIX} ninja install ${PKG_MAKEINSTALL_OPTS_TARGET}
      DESTDIR=${INSTALL} ninja install ${PKG_MAKEINSTALL_OPTS_TARGET}
      ;;
    "meson:host"|"cmake:host")
      ninja install ${PKG_MAKEINSTALL_OPTS_HOST}
      ;;
    "meson:init"|"cmake:init")
      DESTDIR=${INSTALL} ninja install ${PKG_MAKEINSTALL_OPTS_INIT}
      ;;
    "meson:bootstrap"|"cmake:bootstrap")
      ninja install ${PKG_MAKEINSTALL_OPTS_BOOTSTRAP}
      ;;

    # make based builds
    "configure:target"|"cmake-make:target"|"autotools:target"|"make:target")
      make install DESTDIR=${SYSROOT_PREFIX} -j1 ${PKG_MAKEINSTALL_OPTS_TARGET}
      make install DESTDIR=${INSTALL} ${PKG_MAKEINSTALL_OPTS_TARGET}
      ;;
    "configure:host"|"cmake-make:host"|"autotools:host"|"make:host")
      make install ${PKG_MAKEINSTALL_OPTS_HOST}
      ;;
    "configure:init"|"cmake-make:init"|"autotools:init"|"make:init")
      make install DESTDIR=${INSTALL} ${PKG_MAKEINSTALL_OPTS_INIT}
      ;;
    "configure:bootstrap"|"cmake-make:bootstrap"|"autotools:bootstrap"|"make:bootstrap")
      make install ${PKG_MAKEINSTALL_OPTS_BOOTSTRAP}
      ;;
  esac
fi

echo "post_makeinstall 环节"
pkg_call_exists post_makeinstall_${TARGET} && pkg_call post_makeinstall_${TARGET}

# Fixup temporary sysroot references to the shared sysroot
for i in $(find "${SYSROOT_PREFIX}/usr/lib" -type f -name "*.la" 2>/dev/null); do
  sed -e "s:\(['= ]\)/usr:\\1${PKG_ORIG_SYSROOT_PREFIX}/usr:g" -i "${i}"
done
for i in $(find "${SYSROOT_PREFIX}/usr/bin" -type f -name "*-config" 2>/dev/null); do
  sed -e "s#${SYSROOT_PREFIX}/usr#${PKG_ORIG_SYSROOT_PREFIX}/usr#g" -i "${i}"
done
for i in $(find "${SYSROOT_PREFIX}/usr/lib" -type f -name "*.pc" 2>/dev/null); do
  sed -e "s#${SYSROOT_PREFIX}/usr#${PKG_ORIG_SYSROOT_PREFIX}/usr#g" -i "${i}"
done
for i in $(find "${SYSROOT_PREFIX}/usr"/{lib,share} -type f -name "*.cmake" 2>/dev/null); do
  sed -e "s#${SYSROOT_PREFIX}/usr#${PKG_ORIG_SYSROOT_PREFIX}/usr#g" -i "${i}"
done
for i in $(find "${SYSROOT_PREFIX}" -type l 2>/dev/null); do
  _tmp="$(readlink -m "${i}")"
  [[ ${_tmp} =~ ^/usr ]] && _tmp="${SYSROOT_PREFIX}${_tmp}"
  if [[ ${_tmp} =~ ^${SYSROOT_PREFIX}/ ]]; then
    ln -sfn "${_tmp/${SYSROOT_PREFIX}\//${PKG_ORIG_SYSROOT_PREFIX}\/}" "${i}"
  fi
done

# Transfer the new sysroot content to the shared sysroot
mkdir -p "${PKG_ORIG_SYSROOT_PREFIX}"
cp -PRf "${SYSROOT_PREFIX}"/* "${PKG_ORIG_SYSROOT_PREFIX}"
rm -rf "${SYSROOT_PREFIX}"

export SYSROOT_PREFIX="${PKG_ORIG_SYSROOT_PREFIX}"

if [ "${TARGET}" = "target" -o "${TARGET}" = "init" ]; then
  if [ -d ${INSTALL} ]; then
    rm -rf ${INSTALL}/{usr/,}include
    rm -rf ${INSTALL}/{usr/,}lib/cmake
    rm -rf ${INSTALL}/{usr/,}lib/pkgconfig
    rm -rf ${INSTALL}/{usr/,}man
    rm -rf ${INSTALL}/{usr/,}share/aclocal
    rm -rf ${INSTALL}/{usr/,}share/bash-completion
    rm -rf ${INSTALL}/{usr/,}share/doc
    rm -rf ${INSTALL}/{usr/,}share/gtk-doc
    rm -rf ${INSTALL}/{usr/,}share/info
    rm -rf ${INSTALL}/{usr/,}share/locale
    rm -rf ${INSTALL}/{usr/,}share/man
    rm -rf ${INSTALL}/{usr/,}share/pkgconfig
    rm -rf ${INSTALL}/{usr/,}share/zsh
    rm -rf ${INSTALL}/{usr/,}var
    find ${INSTALL} \( -name "*.orig" \
                  -o -name "*.rej" \
                  -o -name "*.a" \
                  -o -name "*.la" \
                  -o -name "*.o" \
                  -o -name "*.in" \
                  -o -name ".git*" \) \
        -exec rm -f {} \; 2>/dev/null || :
    find ${INSTALL} -type d -exec rmdir -p {} \; 2>/dev/null || :

    if [ ! "${BUILD_WITH_DEBUG}" = "yes" ]; then
      ${STRIP} $(find ${INSTALL} \
        -type f -name "*.so*" \
        ! -name "ld-*.so" \
        ! -name "libc-*.so" \
        ! -name "libpthread-*.so" \
        ! -name "libthread_db-*so" \
        2>/dev/null) 2>/dev/null || :
        if [ "${TARGET}" = "init" ]; then
          ${STRIP} $(find ${INSTALL} -type f -name "*.so*" 2>/dev/null) 2>/dev/null || :
        fi
        ${STRIP} $(find ${INSTALL} ! -name "*.so*" ! -name "*.ko" \
          -type f -executable 2>/dev/null) 2>/dev/null || :
    fi
  fi
fi

cd ${ROOT}

PKG_DEEPHASH=$(calculate_stamp)
for i in PKG_NAME PKG_DEEPHASH BUILD_WITH_DEBUG; do
  echo "STAMP_${i}=\"${!i}\"" >> ${STAMP}
done

pkg_lock_status "UNLOCK" "${PKG_NAME}:${TARGET}" "build" "built"

echo "build 结束运行"
